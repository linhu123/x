## 位运算

1. 位运算与进制基础

* 在处理整形数值时，可以直接对组成整形数值的各个位进行操作。这意味着可以使用屏蔽技术获得整数中的各个位。
* &（与）、｜（或）、^ (异或)二者不同时为一、～（取反）
* \>> 和 \<< 运算符将二进制位进行右移或者左移操作。
* \>>> 运算符将用0填充高位；>>运算符用符号位填充高位，没有<<< 运算符。
* 对于int 1<< 35 与 1 << 3 是相同的。而左边的操作数是long类型时需对右侧操作数模64。
* 异或

2. 题解

___
**习题**

+ 找出重复的数值
+ 一个数组中除了某一个数字之外，其他的数字都出现了两次。找出这样的数值。
+ t4 用一条语句判断一个整数是不是2的整次方
    + if((（n-1）& n) == 0) 是2的整数次方
    + else 不是2的整数次方
+ t5 将整数的奇偶位互换
    + 方法一：使用java转成二进制字符串，通过遍历进行求解。
    + 方法二：）0xaaaaaaaa 与运算保留偶数位 0x55555555 与运算保留奇数位。

+ t6 给定一个介于0和1之间的实数，（如 0.625),类型为double,打印他的二进制表示（0.101） 因为小数点后的二进制分别表示0.5,0.25,0.125 如果该数字无法精确地用32位以内的二进制表示，则打印"ERROR"
+ t7 数组当中只有一个数出现了1次，其他的数都出现了k次，请输出只出现了1次的数。
    + 2个相同的2进制数做不进位，及过为0
    + 10个相同的10进制数做不进位加法，结果为0
    +
    + 进制的任意转换：1-手工取余法 2-Integer.toString(i,radix) radix表示要转换的进制

___

## 递归

1. 对递归建立感觉
2. 学会评估算法性能
3. 能大致预估程序执行时间

---

### 递归设计经验

1. 找重复（子问题）
2. 找重复中的变化量->参数
3. 找参数变化趋势->设计出口

### 练习策略

1. 循环改递归
2. 经典递归
3. 大量练习，总结规律，掌握套路
4. 找到感觉，调整高难度

### 基础练习

1. 求阶乘

```
  //求一个数的阶乘
  //n*(n-1)*(n-2)*----*1
  public static int jiecheng(int n){
    if(n == 1){
      return n;  
    }else{
      return n * jiecheng(n-1);
    }
  } 
```

2. 打印i-j

```
i 不变 j每次加大，直到i和j一样大

```

3. 数组求和

```
//对arr的所有元素求和
public static int add(int[] arr,int index){
  if(index >= arr.length){
    return 0;
  }else{
    return arr[index] + add(arr,++index);
  }
}

```

4. 反转字符串
5. 斐波那契数列

```
// 1,1,2,3,5,8,13-------
//第一项和第二项是1，从第三项开始后面每一项都是前两项的和。
```

6. 最大公约数

```
public static int gcd(int m,int n)
{
  if(n==0) return n;
  return gcd(n,m%n)
}

```

7. 插入排序改递归
```aidl
 

```
8. 汉诺塔

## 查找和排序
1. 分治思想：快速排序和归并排序
2. 小和，逆序对等问题求解
3. 空间结构之法：堆排序，计数排序等
4. 排序算法小结
5. 题解

---

分治法 DC：将原问题划分为若干个规模较小而结构与原问题一致的子问题；递归的解决这些子问题，然后再合并其结果，就得到原问题的解。


容易确定运行时间，是分治算法的特点


分治模式再每一层递归上都有三个步骤：
- 分解 将原问题分解成一系列子问题。
- 解决 递归的解决各个子问题。若子问题足够小，则直接有解。
- 合并 将子问题的结果合并成原问题的解。


---

1. 快速排序
```aidl
 
```

2. ae
3. qwads
4. asd
5. sss






